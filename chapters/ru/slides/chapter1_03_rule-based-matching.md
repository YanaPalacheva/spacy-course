---
type: slides
---

# Поиск совпадений по шаблонам

Notes: В этом уроке мы научимся искать слова и фразы в тексте по заданным шаблонам с помощью 
специального объекта spaCy: матчера (от англ. "match" - соответствие).

---

# Почему бы просто не использовать регулярные выражения?

- Поиск по объектам `Doc`, а не только по строкам
- Поиск по токенам и их атрибутам
- Использование предсказаний модели
- Пример: "duck" (глагол, "нагибаться") vs. "duck" (существительное, "утка")

Notes: В отличие от регулярных выражений, матчер может работать как со строками, так и с 
объектами `Doc` и `Token`.

Кроме того, он более гибкий: с помощью него можно осуществлять поиск 
не только по тексту, но и по лексическим атрибутам.

Можно даже задавать шаблоны, которые используют предсказания модели.

Например, искать упоминания слова "duck" ("утка" или "нагибаться") 
исключительно как глагола, не существительного.

---

# Шаблоны поиска

- Список словарей, один на каждый токен

- Поиск точного совпадения текстовых значений

```python
[{"TEXT": "iPhone"}, {"TEXT": "X"}]
```

- Поиск совпадений по лексическим атрибутам

```python
[{"LOWER": "iphone"}, {"LOWER": "x"}]
```

- Поиск совпадений по различным атрибутам токенов

```python
[{"LEMMA": "buy"}, {"POS": "NOUN"}]
```

Notes: Шаблон поиска представляет собой список словарей. Каждый словарь описывает один токен.
Ключом в данном случае являются название атрибута токена, а значение описывает ожидаемый результат 
для данного атрибута.

В этом примере мы рассматриваем два токена с текстовыми значениями "iPhone" и "X".

Теперь необходимо найти последовательность из таких двух токенов, у которых текстовые значения 
в нижнем регистре равны "iphone" и "x" соответственно. Также мы можем использовать в 
поиске и другие атрибуты токенов.

Мы даже можем задавать шаблоны, которые используют предсказанные атрибуты токенов.
В этом примере мы ищем такую последовательность токенов, чтобы лемма первого токена была 
"buy" ("купить"), а второй токен был существительным. Лемма - это базовая форма слова, 
поэтому этому шаблону будут соответствовать такие фразы, как "buying milk" ("покупая молоко") 
и "bought flowers" ("купил цветы").

---

# Использование матчера (1)

```python
import spacy

# Испорт класса Matcher
from spacy.matcher import Matcher

# Загрузка модели и создание объекта nlp
nlp = spacy.load("en_core_web_sm")

# Инициализация матчера с общим вокабуляром в виде аргумента
matcher = Matcher(nlp.vocab)

# Добавление шаблона в матчер
pattern = [{"TEXT": "iPhone"}, {"TEXT": "X"}]
matcher.add("IPHONE_PATTERN", None, pattern)

# Обработка текста
doc = nlp("Upcoming iPhone X release date leaked")

# Вызов матчера c документом doc в качестве аргумента
matches = matcher(doc)
```

Notes: Чтобы использовать шаблон, нам в первую очередь нужно импортировать 
класс `Matcher` из `spacy.matcher`.

Также нужно загрузить модель и создать объект `nlp`.

При инициализации матчера общий вокабуляр `nlp.vocab` используется в качестве аргумента. 
Мы вернёмся к этому позже, пока же достаточно помнить, что его всегда нужно передавать 
во время инициализации.

Метод `matcher.add` позволяет добавить шаблон в матчер. Первый аргумент - это 
уникальный идентификатор шаблон. Второй аргумент опциональный, он зарезервирован для 
функции обратного вызова. Здесь она нам не нужна, поэтому мы присваиваем аргументу `None`.
Третий аргумент - шаблон.

Чтобы найти соответствие шаблону в тексте, необходимо вызвать матчер с 
любым документом в качестве аргумента.

Этот вызов вернёт список найденных совпадений.

---

# Использование матчера (2)

```python
# Вызов матчера c документом doc в качестве аргумента
doc = nlp("Upcoming iPhone X release date leaked")
matches = matcher(doc)

# Перебор найденных соответствий
for match_id, start, end in matches:
    # Получение спана для найденного соответствий
    matched_span = doc[start:end]
    print(matched_span.text)
```

```out
iPhone X
```

- `match_id`: хэш-значение названия шаблона
- `start`: начальный индекс найденного соответствия
- `end`: конечный индекс найденного соответствия

Notes: Вызов матчера с документов в качестве аргумента возвращает список кортежей.

Каждый кортеж состоит из трёх значений: идентификатор, начальный индекс и 
конечный индекс найденного соответствия.


Это означает, что мы можем перебирать найденные соответствия в цикле и создавать 
объекты `Span`: срезы документа по начальному и конечному индексу.

---

# Поиск совпадений по лексическим атрибутам

```python
pattern = [
    {"IS_DIGIT": True},
    {"LOWER": "fifa"},
    {"LOWER": "world"},
    {"LOWER": "cup"},
    {"IS_PUNCT": True}
]
```

```python
doc = nlp("2018 FIFA World Cup: France won!")
```

```out
2018 FIFA World Cup:
```

Notes: Это пример более сложного шаблона, использующего лексические атрибуты.

Мы ищем последовательность из пяти токенов:

Токен, состоящий только из цифр.

Три токена, у которых текстовые значения в нижнем регистре 
совпадают с "fifa", "world" и "cup" соответственно.

И заключительный токен, состоящий из знаков препинания.

Этому шаблону соответствует следующая последовательность токенов: "2018 FIFA World Cup:".

---

# Поиск совпадений по другим атрибутам токенов

```python
pattern = [
    {"LEMMA": "love", "POS": "VERB"},
    {"POS": "NOUN"}
]
```

```python
doc = nlp("I loved dogs but now I love cats more.")
```

```out
loved dogs
love cats
```

Note: В этом примере мы ищем последовательность из двух токенов:

Глагол с леммой "love" ("любить"), за которым следует существительное.

Этому шаблону соответствуют фразы "loved dogs" ("любил собак") и "love cats" ("люблю кошек").

---

# Использование операторов и кванторов (1)

```python
pattern = [
    {"LEMMA": "buy"},
    {"POS": "DET", "OP": "?"},  # optional: match 0 or 1 times
    {"POS": "NOUN"}
]
```

```python
doc = nlp("I bought a smartphone. Now I'm buying apps.")
```

```out
bought a smartphone
buying apps
```

Notes: Операторы и кванторы позволяют регулировать, сколько раз токен
должен появляться во фразе, чтобы она была включена в результат поиска по шаблону. 
Их можно добавить в шаблом по ключу "OP".

В данном примере оператор "?" делает токен артикля опциональным, то есть 
этому шаблону будет соответствовать следующая последовательность: 
токен с леммой "buy", опциональный артикль и существительное.

---

# Использование операторов и кванторов (2)

| Пример        | Описание                                       |
| ------------- | ---------------------------------------------- |
| `{"OP": "!"}` | Отрицание: не включать                         |
| `{"OP": "?"}` | Опциональность: не включать или включать 1 раз |
| `{"OP": "+"}` | Включать 1 или больше раз                      |
| `{"OP": "*"}` | Включать 0 или больше раз                      |

Notes: Оператор "OP" может принимать следующие значения:

"!" отбрасывает токен, то есть он не включается в последовательность.

"?" делает токен опциональным, то есть он любо не включён, либо включён 1 раз.

"+" позволяет включать токен как минимум 1 раз.

И наконец, "\*" позволяет включать токен сколько угодно раз (0 и более).

Операторы могут сделать шаблон очень эффективным, но в то же время они добаляют 
сложности, поэтому их нужно использовать с умом.

---

# Давайте потренируемся!

Notes: Поиск совпадений по шаблонам на основе токенов открывает новые возможности для 
извлечения информации их текста. Давайте опробуем этот метод и напишем несколько 
шаблонов самостоятельно!
